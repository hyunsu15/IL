# 객체지향 다시 보기

## 요약

- 열거형활용은 객체지향을 더욱 빛나게 한다.
- 인터페이스 활용 설계를 더 고민하자.

## 문제점 상황

NhN 아카데미에서 javaFx로 벽돌깨기 게임을 구현하는 미션을 받았습니다.
4장 까지 수도코드를 보고, 해당기능을 구현할수 있을 것 같아서 4장까지 교재대로하고 평소에 내가 하던대로 구현했습니다.

```
public interface Brick {
  Point getLeftTop();
  default Point getCenter(){
    return getLeftTop().add(new Vector2D((double) getWidth()/2,(double) getHeight()/2));
  }

  int getWidth();
  int getHeight();

  long getHp();
  void  setHp(long newHp);
  default void gainDamage(){
    if(getHp()<=0)
      return;
    setHp(getHp()-1);
  }
}
```

해당 인터페이스를 만들고 요구사항에 맞는 브릭 종류를 만들었다.

- simpleBrick(피가 1인 브릭)
- mutlihitBrick(피가 n인 브릭)
- explodingBrick(맞으면 폭발하는 브릭)
- powerUpBrick(맞으면 파워업하는 브릭)

그리고 볼과  볼을 튕기는 객체(패들), 볼과 브릭을 하는 객체를 충격을 계산하는 클래스를 따로 만들어둬었습니다.

또한 예제로 만든 볼을 조합하여, 조금더 유연한 코드를 만들고 싶었다.
```
// 임포트 예제로만든 BoundedBall
public class BoundBall {
  private BoundedBall ball;
  ...

  }
```

## 주요피드백

- BoundBall을 BoundedBall에서 상속하지 않고, 필드로 가져야할 이유는? 코드는 대부분 BoundedBall을 가져오면 되고, increaseSpeed 메서드만 추가 되었으므로, 상속 후 메서드 추가가 더 좋지 않을까요?

- Brick 인터페이스는 무엇을 위한 것인가? SimpleBrick, ExplodingBrick,  MultiHitBrick, PowerUpBrick에서 Brick 인터페이스를 구현하지만 차이가 없음

- ExplodingBrick과 차이는 ? 충돌시 처리 방식이 다른 것인가? 그럼, hp = 1의 의미는?

- 벽돌 충돌관리자,이는 불필요한 중복 코드, 유지보수 부담 증가, 타입 시스템 복잡도 증가를 의미함.

피드백들을 듣고, 한대 쌔게 얻어 맞은 기분이었다. 작성했던 코드가 잘만들어진 코드라고 자부했었다. 피드백은 다 맞는말이었다.

## 교재 내용

제대로 공부해보고 싶어졌다. 보지 않았던 4장이후의 교재를 읽기 시작했다. 내가 작성하는 방식의 코드는 아래와 같이 명시 되어있었다.

```
클래스 폭발이란? 각 기능의 조합마다 새로운 클래스를 만들어야 하는 문제입니다. 예를 들어:

Box만 있는 클래스
움직이는 Box 클래스
색깔이 있는 Box 클래스
움직이고 색깔이 있는 Box 클래스
... 계속 증가!
PaintableMovableBox:

MovableBox를 상속받아 색상 추가
필드: color
문제: PaintableBox와 코드 중복
BoundedPaintableMovableBox:

PaintableMovableBox를 상속받아 경계 처리 추가
문제: 클래스 이름이 너무 길어짐!
조합 폭발:

3개 기능 = 2³ = 8개 클래스
4개 기능 = 2⁴ = 16개 클래스
n개 기능 = 2ⁿ개 클래스!
```

```

각 타입 조합마다 별도의 충돌 처리 로직이 필요합니다:

필요한 메서드들:

Ball-Ball 충돌

탄성 충돌 처리
운동량 보존
Box-Box 충돌

사각형 간 충돌
별도 로직 필요
Ball-Box 충돌

어느 면과 충돌했는지 확인
면 충돌 vs 코너 충돌
완전히 다른 처리 필요
조합 폭발:

2개 타입: 3개 메서드
3개 타입: 6개 메서드
4개 타입: 10개 메서드
n개 타입: n(n+1)/2개 메서드
```

그리고 교재에는 다음과 같이 충돌을 처리했다.
```
public interface Boundable {
  Bounds getBounds();
  boolean isColliding(Boundable other);
}

public interface Collidable extends Boundable{
  void handleCollision(Collidable other);
  CollisionAction getCollisionAction();
}
```

그리고 충돌시 액션은 열거형으로 만들어서 유연성을 한층 업시켰다.

```
CollisionAction 열거형:

BOUNCE: 반사
DESTROY: 파괴
STOP: 정지
PASS: 통과
CUSTOM: 사용자 정의
```

```
// 충돌 처리 switch 문
switch (collisionAction) {
    case BOUNCE:
        // 반사 로직
        break;
    case DESTROY:
        // 제거 표시
        break;
    // ...
}
```

## 느낀 점

해당 설명들과 코드들을 보고 감탄했다. 특히 Boundable-Colliable은 생각해보지 못한 요소였다. 교재 방식으로 작성하니 수정에도 용이하고, 확장에도 용이했다. 내가 작성했던 코드 경우 충돌시 이벤트를 잘 처리하지 못했다.

이론을 어느정도 알고 있다고 생각했지만, 역시 오만이었다. 해당 코드들은 정말 이론에 부합하고 실전성도 있는 코드들이었다. 해당 수업을 듣고 다른 과제를 적용시켜보았는데 훨씬 코드 짜기 편했다.

## 관련 코드 링크

[피드백전_벽돌꺠기_코드](https://github.com/hyunsu15/breakoutGame_comments)

[피드백_받고만든 캐논볼](https://github.com/hyunsu15/cannon_Game)
