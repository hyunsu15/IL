## 참고자료

[JDKPROXY과CGLIB](https://www.youtube.com/watch?v=MFckVKrJLRQ)

[스프링 트랜잭션에 대한 전반적인 개요](https://www.youtube.com/watch?v=cc4M-GS9DoY)
- 적당히 깊고 얇아서 추천. jdbc을 추상화하지만, jpa와 어차피 인터페이스로 의존하기에 상세구현은 달라도 호출은 차이없음.


[참고자료](https://brunch.co.kr/@anonymdevoo/44)

디버깅

## 트랜잭션

@EnableTransactionManagement
- 이 어노테이션으로 트랜잭션 어노테이션 작동하게 됨.
@Import({TransactionManagementConfigurationSelector})를 들어가보면
aspectj와 proxy 선택하여, 프록시관련 설정이 들어감.

기본값인 ProxyTransactionManagementConfiguration
- 여기서 Spring ProxyFactoryBean의 advisor(methodInterceptor+포인트 컷,포인트컷은 내부에 구현되어있음.),methodInterceptor 트랜잭션 설정을 초기화

이것의 부모인 AbstractTransactionManagementConfiguration은
TransactionAttributeSource와 TransactionalEvenListenerFactory를 생성함.

AnnotationTransactionAttributeSource에서는 어노테이션 파서가 있음.

대표적으로 SpringTransactionAnntationParser를 보면 @Transactional 속성관련 룰을 파싱함.

~~~
Propagation propagation = attributes.getEnum("propagation");
		rbta.setPropagationBehavior(propagation.value());
		Isolation isolation = attributes.getEnum("isolation");
		rbta.setIsolationLevel(isolation.value());

		rbta.setTimeout(attributes.getNumber("timeout").intValue());
		String timeoutString = attributes.getString("timeoutString");
		Assert.isTrue(!StringUtils.hasText(timeoutString) || rbta.getTimeout() < 0,
				"Specify 'timeout' or 'timeoutString', not both");
		rbta.setTimeoutString(timeoutString);

		rbta.setReadOnly(attributes.getBoolean("readOnly"));
		rbta.setQualifier(attributes.getString("value"));
		rbta.setLabels(Set.of(attributes.getStringArray("label")));

		List<RollbackRuleAttribute> rollbackRules = new ArrayList<>();
		for (Class<?> rbRule : attributes.getClassArray("rollbackFor")) {
			rollbackRules.add(new RollbackRuleAttribute(rbRule));
		}
		for (String rbRule : attributes.getStringArray("rollbackForClassName")) {
			rollbackRules.add(new RollbackRuleAttribute(rbRule));
		}
		for (Class<?> rbRule : attributes.getClassArray("noRollbackFor")) {
			rollbackRules.add(new NoRollbackRuleAttribute(rbRule));
		}
		for (String rbRule : attributes.getStringArray("noRollbackForClassName")) {
			rollbackRules.add(new NoRollbackRuleAttribute(rbRule));
		}

~~~


Spring MVC 기준
AnnotationConfigServletWebApplicationContext가 ApplicationContext임.
부모인 GenericApplicationContext에 있는 DefaultListableBeanFactory의 부모 AbstractAutowireCapableBeanFactory에서 빈 후처리기의 빈초기화전 처리,후처리를 처리함.

후처리에서 Aop가 되는지 체크후
프록시를 만듬.

해당 빈 후처리기는 DefaultAdvisorAutoProxyCreator
를 쓰고, 부모메소드를 사용함.
AbstractAutoProxyCreator에서 프록시를 실질적으로 만듬.


TransactionInterceptor
TransactionAspectSupport상속하며, 프록시인 객체(Spring ProxyFactory Bean을 이용함.)
부모(TransactionAspectSupport)의 메소드를 호출함.

TransactionAspectSupport
해당 트랙잭션의 시작, 커밋, 롤백과 같은 '비즈니스 로직 외적인 트랜잭션 제어 로직'을 모두 담고 있는 핵심 본체

TransactionManager
마커인터페이스 이것은 platformTranscationManager와 reactiveTransactionManager의 부모이다.


Transaction Definition
전파,격리수준,타임아웃

Transaction status
트랜잭션의 현재상태

### 팁
스프링 프레임워크 6.1부터는 CompetableFuture alc future 특별한 처리지원
- 전엔 알맹이 검사안해서 롤백을 개발자가 신경썻어야 함.
- 지금은 스프링에서 알아서 해줌.

롤백
- classType ClazzName.class,자식도 가능
- className 이름매칭. 이것은 있지만 비추천. 이름이 같다는 이유로 롤백하고싶은데 롤백될 수 있음.
exceptionHandler 처럼 구체적인 것을 우선순위가 높음.

스프링 6.0부터 cglib을 사용할 경우, protected,패키지 private(default)도 트랜잭션 어노테이션 적용가능.
