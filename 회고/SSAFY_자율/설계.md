# 설계

설계 관련 이야기.

요약) 성공했으나, 살짝은 아쉬웠다.



## 원래 계획

FrontEnd: React.js

BackEnd: Spring

웹서버: nginx



CI: jenkins

CD:sonarqube

DB: mysql

컨테이너 오케스트레이션 - k8s



특화때 했던 것과 sonarqube 와 컨테이너 오케스트레이션 의 디펙토인 k8s를 사용하는 것이 초기 목표였다.



## 프로젝트 끝날당시 설계

컨테이너 오케스트레이션 - docker-swarm

아래는 오케스트레이션에 의해 관리되는 컨테이너

FrontEnd: React.js

BackEnd: Spring

웹서버: nginx

-------------------------

docker-compose.yml로 관리되는 단일 컨테이너들

CI: jenkins

CD:sonarqube

DB: mysql



초기와 달라진 점

1. k8s -> docker swarm

   이렇게 바꾼 점은 주어진 자원을 최대한 효율하기 위해서 변경했다.  교보재 신청을 빨리 신청을 받았다. 그리고 k8s를 공부를 하기 전 상태였다. 그래서, 기술을 알지 못한 채 서버를 2대만 신청했다. 

    k8s를 공부하다보니, 적어도 서버가 3-4+a개 정도는 있어야 효율적이라는 점을  느꼈다.  control pane은 컨트롤를 담당하는 노드. worker node는 일을 하는 노드  와 같이 명확히 분리되어있는 형식이었다. 

    서버를 두개를 받은 상황에서, 하나를 컨트롤,하나를 worker node로 쓰는 건 그렇게 효율적이지 못하는 판단을 했다.  k8s도 찾아보면, 저런 상황에서 해결법이 있을 수 있지만, 찾지는 못했다.

   그래서 docker swarm을 쓰기로 했다. docker swarm은 k8s와 같이 분리가 되어있지만, 컨테이너 운용시에는 control pane도 컨테이너를 운용하기때문에 효율적이라고 판단했다.

   ​



## 배포 관련 느낀점

1. 멀티 서버로 가니, 생각해줘야할 부분들이 많았다.

   서버 한대에서 모든것을 해결했다는 편했다. 그냥, 한 서버 내에서, CI/FE/BE/DB등 모든 것 처리했기 때문이다.

    하지만, 서버가 2대 이상으로 늘어나면서 생각해야할 요소들이 생겼다. 이 컨테이너가 다른 서버에도 있어되는지, 더 효율적인 방법이 있는지를 생각하게 되었다.





 

 

